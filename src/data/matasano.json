{"ex01":{"title":"Exercise 1","body":"<h1>Exercise 01</h1>\n<p>This is the <a href=\"http://cryptopals.com/sets/1/challenges/1/\">first Matasano challenge</a>,\na very simple one. We just need to convert the following hex string:</p>\n<pre><code><span class=\"hljs-number\">49276d</span>206b696c6c696e6720796f757220627261696e\n<span class=\"hljs-number\">206</span>c696b65206120706f69736f6e6f7573206d757368\n<span class=\"hljs-number\">726f</span>6f6d\n</code></pre>\n<p>to base64:</p>\n<pre><code>SSdtIGtpbGxpbmcgeW<span class=\"hljs-number\">91</span>ciBicmFpbiBsaWtlIGEgc<span class=\"hljs-name\">G9</span>p\nc<span class=\"hljs-number\">29</span>ub<span class=\"hljs-number\">3</span>VzI<span class=\"hljs-name\">G11</span>c<span class=\"hljs-number\">2</span>hyb<span class=\"hljs-number\">29</span>t\n</code></pre>\n<p>Let's get started! This isn't a very complicated problem, so our\nprogram isn't very complicated either.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/base64\"</span>\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-keyword\">const</span> (\n    hexString    <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d\"</span>\n    base64Answer <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    rawBytes, _ := hex.DecodeString(hexString)\n    base64Output := base64.StdEncoding.EncodeToString(rawBytes)\n\n    fmt.Printf(<span class=\"hljs-string\">\"hex encoding: %s\\nbase64 encoding: %s\\n\"</span>, hexString, base64Output)\n\n    <span class=\"hljs-keyword\">if</span> base64Output == base64Answer {\n        fmt.Println(<span class=\"hljs-string\">\"it works! hooray!\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.Println(<span class=\"hljs-string\">\"sad :(\"</span>)\n    }\n}\n</code></pre>\n<p>Basically, all we've done is use some functions from the <code>encoding</code> module.\nI learned a bit about Go syntax, modules, and build stuff doing this.</p>\n"},"ex02":{"title":"Exercise 2","body":"<h1>Exercise 2</h1>\n<p>The <a href=\"http://cryptopals.com/sets/1/challenges/2/\">2nd Matasano challenge</a>!\nNow we're doing fixed XOR. Basically, we have two input strings:</p>\n<pre><code><span class=\"hljs-symbol\">s1:</span> <span class=\"hljs-number\">1</span>c0111001f010100061a024b53535009181c\n<span class=\"hljs-symbol\">s2:</span> <span class=\"hljs-number\">686974207468652062756</span>c6c277320657965\n</code></pre>\n<p>We want to do a pairwise XOR on them (<code>for n in len(s1), do s1[n] XOR s2[n]</code>)\nand check that the output looks like this (when hex encoded):</p>\n<pre><code>output: <span class=\"hljs-number\">746865206</span>b696420646f6e2774<span class=\"hljs-number\">20706c6179</span>\n</code></pre>\n<p>Great, let's go!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n)\n</code></pre>\n<p>First, a little function that performs the XOR operation for us.\nIt just takes in two byte arrays, and iterates through doing the\nXOR operation:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fixedXOR</span><span class=\"hljs-params\">(a1, a2 []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span></span> {\n    bytes = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(a1))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> a1 {\n        bytes[i] = v ^ a2[i]\n    }\n    <span class=\"hljs-keyword\">return</span>\n}\n</code></pre>\n<p>Here's the correct answer, which we'll check after we've done the\ncomputation.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">const</span> correctAnswer <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"746865206b696420646f6e277420706c6179\"</span>\n</code></pre>\n<p>Here's our main function, where we'll do all the work. Go is a bit\nlike C, in that, if you have <code>package main</code> up top, a function called\n<code>main</code> will automatically be called when you run the binary built from\nthis file.</p>\n<p>Go seems to be a bit picky about positional returns - here the\n<code>hex.DecodeString</code> method returns two values, a byte slice and\na boolean that signals if there were any errors.</p>\n<p>We're not really expecting any, so we'll use the <code>_</code> to signal\nthat we don't care about putting a name to that value.</p>\n<p>We also get to use the <code>:=</code> operator, which lets us skip declaring\na type for variables we bind. Anything with an inferrable type (a\nreturn from a function, a literal) will cause the type of our variable\nto be automatically inferred. Handy!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    s1, _ := hex.DecodeString(<span class=\"hljs-string\">\"1c0111001f010100061a024b53535009181c\"</span>)\n    s2, _ := hex.DecodeString(<span class=\"hljs-string\">\"686974207468652062756c6c277320657965\"</span>)\n\n    output := fixedXOR(s1, s2)\n    fmt.Println(hex.EncodeToString(output))\n\n    <span class=\"hljs-keyword\">if</span> hex.EncodeToString(output) == correctAnswer {\n        fmt.Println(<span class=\"hljs-string\">\"It works!\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.Println(<span class=\"hljs-string\">\"It doesn't work so much :(\"</span>)\n    }\n}\n</code></pre>\n<p>That's it! Not too much to this problem, really.</p>\n"},"ex03":{"title":"Exercise 3","body":"<h1>Exercise 3</h1>\n<p><a href=\"http://cryptopals.com/sets/1/challenges/3/\">Matasano exercise 3</a>. This asks\nus to break a single byte XOR. Basically, this means that we have a\nciphertext which has been XORed against a single byte. This means we\ncould exhaustively try every byte until we get it, but we're going to at least\ntry to do something a little more elegant.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n</code></pre>\n<p>First off, something we're almost certainly going to need is a function\nthat takes a byte slice and a byte, and XORs the contents of that byte slice\nwith that byte.</p>\n<p>We'll call it <code>arrayXOR</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">arrayXOR</span><span class=\"hljs-params\">(in []<span class=\"hljs-keyword\">byte</span>, n <span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    out := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(in))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> in {\n        out[i] = v ^ n\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Then if we want to XOR a particular byte, say, 42, with a byte array we can\njust do <code>xorResult := arrayXOR(in, byte(42))</code>. Nice!</p>\n<p>We'll also need two little helper functions. They each take an XORed byte\narray and check that the result has some attribute. The first checks that\nthe result contains only printable ASCII characters, and the second checks\nthat the result contains at least one space character (an assumption we make\nabout the content of the plaintext):</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">asciiCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> bytes {\n        <span class=\"hljs-keyword\">if</span> c &gt; <span class=\"hljs-number\">127</span> || c &lt; <span class=\"hljs-number\">32</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">spaceCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-keyword\">string</span>(bytes) {\n        <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-string\">' '</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>We're going to also make one more assumption about the plaintext: we assume\nthat the most common byte in a decoded plaintext will correspond to one of\nthe letters <code>EAOT</code> or a space, since these are the four most common English\nletters. Here's two functions that check for this scenario. The first takes\na string and returns a <code>map[rune]int</code> giving the character counts in the string:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">charCount</span><span class=\"hljs-params\">(str <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">map</span>[<span class=\"hljs-title\">rune</span>]<span class=\"hljs-title\">int</span></span> {\n    counts := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>)\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> str {\n        counts[c]++\n    }\n    <span class=\"hljs-keyword\">return</span> counts\n}\n</code></pre>\n<p>The second function checks that the most common byte in a putative plaintext\nis one of the characters <code>EAOT</code>. To do this we get the character count of a\nlowercased plaintext, find the most common character, and then check to see\nif that is one of our key characters:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">aeotCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    counts := charCount(strings.ToLower(<span class=\"hljs-keyword\">string</span>(bytes)))\n    <span class=\"hljs-keyword\">var</span> biggest <span class=\"hljs-keyword\">rune</span>\n    count := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> counts {\n        <span class=\"hljs-keyword\">if</span> v &gt; count {\n            biggest = k\n            count = v\n        }\n    }\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">\"aeto \"</span> {\n        <span class=\"hljs-keyword\">if</span> biggest == c {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>Great! Together this lets us define a criterion for a valid plaintext:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">validPlaintext</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> asciiCheck(plain) &amp;&amp; spaceCheck(plain) &amp;&amp; aeotCheck(plain)\n}\n</code></pre>\n<h2>Doing the work</h2>\n<p>Now that we've written all of the functions we'll need, we can try to\nsolve the problem!</p>\n<p>Basically, we're dealing with a keyspace of all the values a single byte\ncan take on (0 - 255). This isn't so many, so while we don't want to just\nmanually check each one, it won't be too much work to check the result of\n'decrypting' with each value for certain attributes.</p>\n<p>So, we're basically going to iterate through all the possible keys, attempt\nto decrypt, and then check <code>validPlaintext</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">const</span> cipherText = <span class=\"hljs-string\">\"1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736\"</span>\n    cipherBytes, _ := hex.DecodeString(cipherText)\n\n    keysAndResults := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>)\n\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">255</span>; i++ {\n        plain := arrayXOR(cipherBytes, i)\n        <span class=\"hljs-keyword\">if</span> validPlaintext(plain) {\n            keysAndResults[i] = <span class=\"hljs-keyword\">string</span>(plain)\n        }\n    }\n\n    <span class=\"hljs-keyword\">for</span> k, plain := <span class=\"hljs-keyword\">range</span> keysAndResults {\n        fmt.Printf(<span class=\"hljs-string\">\"key: %d\\tplaintext: %s\\n\"</span>, k, plain)\n    }\n}\n</code></pre>\n<p>Great! After all that we get one key out the end, and a readable plaintext.</p>\n"},"ex04":{"title":"Exercise 4","body":"<h1>Exercise 4</h1>\n<p>In <a href=\"http://cryptopals.com/sets/1/challenges/4\">exercise 4</a> we're given\n326 60-character hex encoded strings, and we're tasked with figuring out\nwhich one has been encoded with single-byte XOR (as seen in <a href=\"/matasano/ex03.html\">exercise 3</a>).</p>\n<p>Should be fun!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> ex04\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n    <span class=\"hljs-string\">\"sort\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n</code></pre>\n<p>This problem seems daunting at first, but it's really not that bad. Let's get\ngoing!</p>\n<p>First off, we're going to be re-using our <code>arrayXOR</code> function from exercise 3:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">arrayXOR</span><span class=\"hljs-params\">(in []<span class=\"hljs-keyword\">byte</span>, n <span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    out := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(in))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> in {\n        out[i] = v ^ n\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Then we need a function to compute a score. This function will be passed a\nputative plaintext value, and we want to score the 'plaintext-ey-ness' of it.\nThis isn't super complicated, basically we have a short list of common letters,\nand we're going to sum the count of those common letters and the number of\nspaces in the plaintext:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">resultScore</span><span class=\"hljs-params\">(result []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">int</span></span> {\n    common := <span class=\"hljs-string\">\"etaoinshrd\"</span>\n    score := <span class=\"hljs-number\">0</span>\n    score += strings.Count(<span class=\"hljs-keyword\">string</span>(result), <span class=\"hljs-string\">\" \"</span>)\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> common {\n        score += strings.Count(<span class=\"hljs-keyword\">string</span>(result), <span class=\"hljs-keyword\">string</span>(c))\n    }\n    <span class=\"hljs-keyword\">return</span> score\n}\n</code></pre>\n<p>It sort of seems like it should be harder than that, but this actually works!</p>\n<p>Anyway moving on, here we're going to declare a struct which will hold a result:\na <code>Key</code>, a potential plaintext (decrypted with that key), and a <code>Score</code>,\ncomputed with our function above:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> XORResult <span class=\"hljs-keyword\">struct</span> {\n    Key    <span class=\"hljs-keyword\">byte</span>\n    Score  <span class=\"hljs-keyword\">int</span>\n    Result []<span class=\"hljs-keyword\">byte</span>\n}\n\n<span class=\"hljs-keyword\">type</span> XORResults []XORResult\n</code></pre>\n<p>When we solve the problem we're going to be building a big array of <code>XORResult</code>\nstructs, and we need a way to find the correct one. Since we're already storing\nthe <code>score</code> of each putative plaintext / key combination, we can implement a few methods\non the struct to satisfy <code>sort.Sort</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(x XORResults)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(x)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(x XORResults)</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span></span> {\n    x[i], x[j] = x[j], x[i]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(x XORResults)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> x[j].Score &lt; x[i].Score\n}\n</code></pre>\n<p>Then, finally, we can put it all together.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BreakXOR</span><span class=\"hljs-params\">(input []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">XORResults</span></span> {\n    results := XORResults{}\n\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">255</span>; i++ {\n        plain := arrayXOR(input, i)\n        result := XORResult{i, resultScore(plain), plain}\n        results = <span class=\"hljs-built_in\">append</span>(results, result)\n    }\n    <span class=\"hljs-keyword\">return</span> results\n}\n</code></pre>\n<p>Great! Now all we're going to do in <code>main</code> is read in the file,\nand then for each line we'll run our <code>BreakXOR</code> function, and then\nmerge the output together (in <code>results</code>). Then we just need to sort\n<code>results</code> and print out the first result!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solveExercise</span><span class=\"hljs-params\">()</span></span> {\n    f, _ := os.Open(<span class=\"hljs-string\">\"./exercise_4.txt\"</span>)\n\n    input := bufio.NewScanner(f)\n    results := XORResults{}\n    <span class=\"hljs-keyword\">for</span> input.Scan() {\n        line, _ := hex.DecodeString(input.Text())\n        result := BreakXOR(line)\n        <span class=\"hljs-keyword\">for</span> _, r := <span class=\"hljs-keyword\">range</span> result {\n            results = <span class=\"hljs-built_in\">append</span>(results, r)\n        }\n    }\n    f.Close()\n\n    sort.Sort(results)\n    fmt.Printf(<span class=\"hljs-string\">\"key: %d\\tplaintext: %s\\n\"</span>, results[<span class=\"hljs-number\">0</span>].Key, results[<span class=\"hljs-number\">0</span>].Result)\n}\n</code></pre>\n<p>And it works! Hooray!</p>\n"},"ex05":{"title":"Exercise 5","body":"<h1>Exercise 5</h1>\n<p>This <a href=\"http://cryptopals.com/sets/1/challenges/5\">exercise</a> asks us to implement\na simple cryptosystem: repeating-key XOR, which is similar to the Vigenere cipher.</p>\n<p>For repeating-key XOR we are going to end up sequentially XORing each byte of\nkey with each byte of the plaintext, so that the first byte of the plaintext will\nbe XORed against the first of the key, the 2nd with the 2nd, and so on. Our key is only\n3 bytes long however, so in general we'll have:</p>\n<p>\\[ C[i] = k[i\\ mod\\ len(k)]\\ XOR\\ P[i] \\]</p>\n<p>where \\(P\\) is our plaintext, \\(k\\) is our key, and \\(C\\) is our ciphertext.\nThe key we're going to be using is <code>ICE</code>, and the plaintext is:</p>\n<pre><code>Burning <span class=\"hljs-symbol\">'em</span>, <span class=\"hljs-keyword\">if</span> you ain<span class=\"hljs-symbol\">'t</span> quick <span class=\"hljs-keyword\">and</span> nimble\nI go crazy <span class=\"hljs-keyword\">when</span> I hear a cymbal\n</code></pre>\n<p>Anyway, turns out this one isn't too complicated. Here we go!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    plaintext := []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"Burning 'em, if you ain't quick and nimble\\nI go crazy when I hear a cymbal\"</span>)\n    key := []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"ICE\"</span>)\n    ciphertext := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(plaintext))\n\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> plaintext {\n        ciphertext[i] = v ^ key[i%<span class=\"hljs-built_in\">len</span>(key)]\n    }\n\n    expected := <span class=\"hljs-string\">\"0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f\"</span>\n\n    <span class=\"hljs-keyword\">if</span> expected == hex.EncodeToString(ciphertext) {\n        fmt.Println(<span class=\"hljs-string\">\"it worked!\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.Println(<span class=\"hljs-string\">\"it didn't work :(\"</span>)\n    }\n}\n</code></pre>\n<p>Cool! we just iterate through our plaintext, and we can use the index of each byte\nthereof to determine which byte of the key to XOR it with. Then, we simply encode the\n<code>[]byte</code> slice to a hex string, and check for equality with the correct answer.</p>\n"},"ex06":{"title":"Exercise 6","body":"<h1>Exercise 6</h1>\n<p>This <a href=\"http://cryptopals.com/sets/1/challenges/6\">problem</a> is a little more\ninvolved than what we've dealt with so far.  We're presented with a base64\nencoded ciphertext, and we're tasked with breaking the encryption and finding\nthe plaintext. The ciphertext has been encrypted using repeating-key XOR, the\nsame cryptosystem we implemented in our last exercise.</p>\n<p>There's a number of things we need to take care of in order to solve the problem,\nlet's just start running through it!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> ex06\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"encoding/base64\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n    <span class=\"hljs-string\">\"sort\"</span>\n\n    <span class=\"hljs-string\">\"../ex04\"</span>\n)\n</code></pre>\n<h2>Keysize</h2>\n<p>The first thing we'll need to figure out it is the correct <code>keysize</code>, defined as\nthe length of the <code>[]byte</code> serving as our key. We have it narrowed down somewhat by\nthe question text, which tells us we only have to worry about keys with lengths\nranging from 2 to 40.</p>\n<p>We'll need one thing before we can get started:</p>\n<h3>Hamming distance</h3>\n<p>The Hamming distance of two <code>ASCII</code> strings is defined as the number of bits\nat which those two strings differ. We'll need to calculate this metric when we're\ntrying to figure out the correct keysize.</p>\n<p>First, though, here's a little function that takes a byte and returns a count of\nthe ones in it's binary representation:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">bitCount</span><span class=\"hljs-params\">(b <span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">int</span></span> {\n    count := <span class=\"hljs-number\">0</span>\n    notOne := ^<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">8</span>; i++ {\n        count += <span class=\"hljs-keyword\">int</span>((b &gt;&gt; i) &amp;^ notOne)\n    }\n    <span class=\"hljs-keyword\">return</span> count\n}\n</code></pre>\n<p>This just takes a byte (<code>b</code>), and then we do some bit-twiddling to check\nwhether each bit in the byte is a one. First, we negate one (<code>^byte(1)</code>) to\nget a mask <code>11111110</code>. Then we can use the <code>AND NOT</code> operator (<code>&amp;^</code>) to check\nthe leftmost bit of <code>b</code>. <code>&amp;^</code> will return <code>0</code> when there is a <code>1</code> in it's second\noperand, so our mask <code>11111110</code> will return <code>0</code> everywhere except in the leftmost\nposition. For <code>&amp;^</code>, when the bit in the second argument is <code>0</code>, it returns the\ncorresponding value in the first operand. So if that's a <code>1</code>, the value of the\nwhole expression will be one, and otherwise it will be zero. Then we can convert\nthat result to an integer, and add that to <code>count</code>, and we can loop from 0 to 8\nand bit-shift our byte to check each bit. Nice!</p>\n<p>How are we going to use that to calculate Hamming distance? Well, we can use bitwise\n<code>XOR</code> to obtain, for two bytes <code>b1</code> and <code>b2</code>, the byte <code>b3</code> where bits are set to <code>1</code>\nif <code>b1</code> and <code>b2</code> had a different value at a given position. Then we can just use\nour <code>bitCount</code> function to count those up!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hamming</span><span class=\"hljs-params\">(b1 []<span class=\"hljs-keyword\">byte</span>, b2 []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">int</span></span> {\n    count := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> b1 {\n        count += bitCount(b1[i] ^ b2[i])\n    }\n    <span class=\"hljs-keyword\">return</span> count\n}\n</code></pre>\n<p>So how are we going to use this, anyway? Well, the utility of the Hamming\ndistance function rests on a bit of a wager. We assume that, if \\(k\\) is the\ncorrect keysize, then the average pairwise Hamming distance of the set \\(K\\)\nof successive chunks of length \\(k\\) pulled from our ciphertext will be lower\nthan a randomly-chosen keysize.  So in order to find the right keysize, we'll\nneed to iterate through the range of possible keysizes and, for each keysize,\nchop up our ciphertext into chunks of that size and record the average pairwise\nHamming distance. Then, the keysize with the lowest average should be correct!</p>\n<p>First, let's write a little function that takes a keysize and a <code>[]byte</code>, and chunks\nit up properly!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">chunks</span><span class=\"hljs-params\">(k <span class=\"hljs-keyword\">int</span>, bytes []<span class=\"hljs-keyword\">byte</span>)</span> [][]<span class=\"hljs-title\">byte</span></span> {\n    out := [][]<span class=\"hljs-keyword\">byte</span>{}\n    tmp := []<span class=\"hljs-keyword\">byte</span>{}\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(bytes); i++ {\n        <span class=\"hljs-keyword\">if</span> i%k == <span class=\"hljs-number\">0</span> &amp;&amp; i != <span class=\"hljs-number\">0</span> {\n            out = <span class=\"hljs-built_in\">append</span>(out, tmp)\n            tmp = []<span class=\"hljs-keyword\">byte</span>{}\n        }\n        tmp = <span class=\"hljs-built_in\">append</span>(tmp, bytes[i])\n    }\n    out = <span class=\"hljs-built_in\">append</span>(out, tmp)\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Now, a function that takes a keysize and a ciphertext, and returns the average pairwise\nHamming distance, normalized by <code>keysize</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">keysizeDistance</span><span class=\"hljs-params\">(keysize <span class=\"hljs-keyword\">int</span>, bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">float64</span></span> {\n    chunked := chunks(keysize, bytes)\n    distance := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> _, chunk := <span class=\"hljs-keyword\">range</span> chunked {\n        distance += hamming(chunk, chunked[<span class=\"hljs-number\">0</span>])\n    }\n    average := <span class=\"hljs-keyword\">float64</span>(distance) / <span class=\"hljs-keyword\">float64</span>(<span class=\"hljs-built_in\">len</span>(chunked))\n    <span class=\"hljs-keyword\">return</span> average / <span class=\"hljs-keyword\">float64</span>(keysize)\n}\n</code></pre>\n<p>With the above function we should be able to figure out the correct keysize -\nthis is a question of simply iterating though the range of possible keysizes\n(\\({a, ..., b}\\)), determining the <code>keysizeDistance</code> score for each, and\nthen taking the smallest result to be \\(k\\), our keysize. Let's write another\nlittle function that does that for us:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">keySize</span><span class=\"hljs-params\">(lower, upper <span class=\"hljs-keyword\">int</span>, bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">int</span></span> {\n    scores := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">float64</span>)\n    <span class=\"hljs-keyword\">for</span> i := lower; i &lt;= upper; i++ {\n        scores[i] = keysizeDistance(i, bytes)\n    }\n    lowestScore := <span class=\"hljs-number\">0.0</span>\n    keysize := <span class=\"hljs-number\">-1</span>\n    <span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> scores {\n        <span class=\"hljs-keyword\">if</span> v &lt; lowestScore || lowestScore == <span class=\"hljs-number\">0.0</span> {\n            lowestScore = v\n            keysize = k\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> keysize\n}\n</code></pre>\n<p>Ok, so we've now got a function that will (hopefully!) let us figure out the\nlength of the key. What can we go with that?</p>\n<h2>Solving the problem</h2>\n<p>Basically, what we're going to take that keysize, use it to break up our\nciphertext into blocks which are encrypted under the same byte, and then find\neach of those bytes using the same methodology we used to break single byte XOR\nin exercise 04. Then, once we've figured out the correct byte for each byte of\nthe key, we can simply decrypt the message! Nice!</p>\n<p>We'll need a few utility functions. First, a little function to split up a byte\nslice into slices based on the index modulo keysize of the elements:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">splitByModulo</span><span class=\"hljs-params\">(size <span class=\"hljs-keyword\">int</span>, bytes []<span class=\"hljs-keyword\">byte</span>)</span> [][]<span class=\"hljs-title\">byte</span></span> {\n    out := [][]<span class=\"hljs-keyword\">byte</span>{}\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ {\n        out = <span class=\"hljs-built_in\">append</span>(out, []<span class=\"hljs-keyword\">byte</span>{})\n    }\n    <span class=\"hljs-keyword\">for</span> i, b := <span class=\"hljs-keyword\">range</span> bytes {\n        out[i%size] = <span class=\"hljs-built_in\">append</span>(out[i%size], b)\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>While we're at it, here's another utility function that just reads in the file\nfor the exercise:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readExerciseInput</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">byte</span></span> {\n    f, _ := os.Open(<span class=\"hljs-string\">\"./ex06.txt\"</span>)\n\n    input := bufio.NewScanner(f)\n    lines := []<span class=\"hljs-keyword\">byte</span>{}\n\n    <span class=\"hljs-keyword\">for</span> input.Scan() {\n        line, _ := base64.StdEncoding.DecodeString(input.Text())\n        <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> line {\n            lines = <span class=\"hljs-built_in\">append</span>(lines, <span class=\"hljs-keyword\">byte</span>(c))\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> lines\n}\n</code></pre>\n<p>Then to find the correct key we just need to break single-byte XOR for each\nmodulo chunk, and we can build up our key byte-by-byte. We'll use <code>BreakXOR</code>\nfrom our exercise 04 solution, and then just return the correct key:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">FindKey</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    size := keySize(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">40</span>, bytes)\n    splits := splitByModulo(size, bytes)\n    key := []<span class=\"hljs-keyword\">byte</span>{}\n    <span class=\"hljs-keyword\">for</span> _, split := <span class=\"hljs-keyword\">range</span> splits {\n        results := ex04.BreakXOR(split)\n        sort.Sort(results)\n        key = <span class=\"hljs-built_in\">append</span>(key, results[<span class=\"hljs-number\">0</span>].Key)\n    }\n    <span class=\"hljs-keyword\">return</span> key\n}\n</code></pre>\n<p>Once we can find a key we're on our way! Now all we need to do is XOR the key\nwith the ciphertext, and we're golden!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">()</span></span> {\n    cipherText := readExerciseInput()\n    key := FindKey(cipherText)\n\n    plainText := []<span class=\"hljs-keyword\">byte</span>{}\n    <span class=\"hljs-keyword\">for</span> i, c := <span class=\"hljs-keyword\">range</span> cipherText {\n        plainText = <span class=\"hljs-built_in\">append</span>(plainText, c^key[i%<span class=\"hljs-built_in\">len</span>(key)])\n    }\n    fmt.Printf(<span class=\"hljs-string\">\"\\nthe key was '%s', and the plaintext:\\n\\n\"</span>, <span class=\"hljs-keyword\">string</span>(key))\n    fmt.Println(<span class=\"hljs-keyword\">string</span>(plainText))\n}\n</code></pre>\n"},"ex07":{"title":"Exercise 7","body":"<h1>Exercise 7</h1>\n<p>Here we want to decrypt the Base64 encoded contents of a file which has been\nencrypted with AES-128 in <a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">ECB (electronic code\nbook)</a> mode. Should be\nfun!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> ex07\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"crypto/aes\"</span>\n    <span class=\"hljs-string\">\"encoding/base64\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"io/ioutil\"</span>\n)\n</code></pre>\n<p>First, let's write a utility function to read in the data:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readExerciseInput</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">byte</span></span> {\n    lines, _ := ioutil.ReadFile(<span class=\"hljs-string\">\"./ex07.txt\"</span>)\n    cipherText, _ := base64.StdEncoding.DecodeString(<span class=\"hljs-keyword\">string</span>(lines))\n    <span class=\"hljs-keyword\">return</span> cipherText\n}\n</code></pre>\n<p>Now what we want is to decrypt the contents of the file! Go has, of course,\nsome nice stuff in the standard library that makes that fairly easy.</p>\n<p>We'll be encrypting under a particular key:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-string\">\"YELLOW SUBMARINE\"</span>\n</code></pre>\n<p>Let's write a little function that takes a ciphertext and a key, and\nreturns the decrypted plaintext.</p>\n<p>This is a little wacky overall, because Go doesn't have official support for\nECB mode in the AES implementation in the standard library. Still, ECB is\nthe simplest block cipher mode, and it's not that hard to get it working ourselves.</p>\n<p>First, a quick little helper that takes two byte slices, and appends the second\nonto the first, returning the mutated first slice:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">appendbytes</span><span class=\"hljs-params\">(dest, src []<span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, b := <span class=\"hljs-keyword\">range</span> src {\n        dest = <span class=\"hljs-built_in\">append</span>(dest, b)\n    }\n    <span class=\"hljs-keyword\">return</span> dest\n}\n</code></pre>\n<p>Then we can do the thing! We take in our ciphertext (a byte slice) and\na key. Then basically all we need to do is create an AES cipher, and then\nmove blockwise through the ciphertext, decrypting as we go, and collecting our\nresults in another byte slice.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">decrypt</span><span class=\"hljs-params\">(ciphertext []<span class=\"hljs-keyword\">byte</span>, key <span class=\"hljs-keyword\">string</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    cipher, _ := aes.NewCipher([]<span class=\"hljs-keyword\">byte</span>(key))\n    bs := cipher.BlockSize()\n    plaintext := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(ciphertext))\n    buffer := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, bs)\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(ciphertext)/bs; i++ {\n        start := i * bs\n        end := start + bs\n        cipher.Decrypt(buffer, ciphertext[start:end])\n        plaintext = appendbytes(plaintext, buffer)\n    }\n    <span class=\"hljs-keyword\">return</span> plaintext\n}\n</code></pre>\n<p>Then just print everything!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solution</span><span class=\"hljs-params\">()</span></span> {\n    cipherText := readExerciseInput()\n    plainText := decrypt(cipherText, key)\n    fmt.Println(<span class=\"hljs-keyword\">string</span>(plainText))\n}\n</code></pre>\n"},"ex08":{"title":"Exercise 8","body":"<h1>Exercise 8</h1>\n<p>In this problem we're given a big list of base64 encoded strings, and we're\ngiven the task of finding out which one has been encoded with AES-ECB.</p>\n<p>Wait, what's ECB mode, anyway?</p>\n<h2>Electronic Codebook mode</h2>\n<p>ECB is a particular way of using a block cipher to encrypt a message.\nEssentially, we devide the message (plaintext) into identically sizes\nblocks, and then we encrypt each block by performing whatever the\nencryption operation is. This looks like this (thanks wikipedia!):</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/ECB_decryption.svg/1202px-ECB_decryption.svg.png\" alt=\"\"></p>\n<p>So any block cipher can be used in ECB mode. Great! How flexible! Chopping\nthe message up into separate blocks, each of which is encrypted\nindependently, also means that the encryption operation can be\nparallelized (since the encryption of any block depends only upon that\nblock's plaintext).</p>\n<p>ECB has a fatal flaw though - this separate encryption means that if your\nmessage plaintext contains two blocks that are identical, then your\nciphertext will also have identical blocks (in the corresponding\npositions).</p>\n<p>This is not good. This means you're vulnerable to some chosen-ciphertext\nattacks, and in particular we're going to leak information about the\nplaintext contents. An attacker could use the pattern of repeated blocks\nto gain information about what type of file is being transmitted, or could\neven again information about file contents. Yikes!</p>\n<h2>Solution</h2>\n<p>This should be pretty straightforward. A major failing of ECB mode (and what\nallows for chosen-plaintext type attack on it and so on) is that a given\n16-byte block in the input (assuming AES-128) will always produce the same\noutput in the ciphertext.</p>\n<p>So we'll just look for that pattern! We're going to basically read in the data,\nand then we'll look for the line which has the highest number of repeated\nblocks. The exercise strongly implies that the block size is 16.</p>\n<p>First, a little utility function to get the data for the exercise:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> ex08\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"io/ioutil\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readExerciseInput</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">string</span></span> {\n    lines, _ := ioutil.ReadFile(<span class=\"hljs-string\">\"./ex08.txt\"</span>)\n    <span class=\"hljs-keyword\">return</span> strings.Split(<span class=\"hljs-keyword\">string</span>(lines), <span class=\"hljs-string\">\"\\n\"</span>)\n}\n</code></pre>\n<p>Now we want to write a function which takes a bite slice and returns a count\nof the repeated blocks in that byte slice:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">scoreECBmode</span><span class=\"hljs-params\">(line []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">int</span></span> {\n    counts := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[[<span class=\"hljs-number\">16</span>]<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">int</span>)\n\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(line); i += <span class=\"hljs-number\">16</span> {\n        <span class=\"hljs-keyword\">var</span> chunk [<span class=\"hljs-number\">16</span>]<span class=\"hljs-keyword\">byte</span>\n        <span class=\"hljs-built_in\">copy</span>(chunk[:], line[i:i+<span class=\"hljs-number\">16</span>])\n        counts[chunk]++\n    }\n\n    <span class=\"hljs-keyword\">for</span> _, k := <span class=\"hljs-keyword\">range</span> counts {\n        fmt.Println(k)\n    }\n    fmt.Printf(<span class=\"hljs-string\">\"\\n\\n\"</span>)\n</code></pre>\n<pre><code>// fmt.Println(counts)\n</code></pre>\n<pre><code class=\"language-go\">score := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> counts {\n        <span class=\"hljs-keyword\">if</span> v != <span class=\"hljs-number\">1</span> {\n            score += v\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> score\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">findECBString</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n    strings := readExerciseInput()\n\n    <span class=\"hljs-keyword\">for</span> _, s := <span class=\"hljs-keyword\">range</span> strings {\n        fmt.Println(scoreECBmode([]<span class=\"hljs-keyword\">byte</span>(s)))\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"asdf\"</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">solveExercise</span><span class=\"hljs-params\">()</span></span> {\n    findECBString()\n}\n</code></pre>\n"}}