{"ex01":{"title":"Exercise 1","body":"<h1>Exercise 01</h1>\n<p>This is the <a href=\"http://cryptopals.com/sets/1/challenges/1/\">first Matasano challenge</a>,\na very simple one. We just need to convert the following hex string:</p>\n<pre><code><span class=\"hljs-number\">49276d</span>206b696c6c696e6720796f757220627261696e\n<span class=\"hljs-number\">206</span>c696b65206120706f69736f6e6f7573206d757368\n<span class=\"hljs-number\">726f</span>6f6d\n</code></pre>\n<p>to base64:</p>\n<pre><code>SSdtIGtpbGxpbmcgeW<span class=\"hljs-number\">91</span>ciBicmFpbiBsaWtlIGEgc<span class=\"hljs-name\">G9</span>p\nc<span class=\"hljs-number\">29</span>ub<span class=\"hljs-number\">3</span>VzI<span class=\"hljs-name\">G11</span>c<span class=\"hljs-number\">2</span>hyb<span class=\"hljs-number\">29</span>t\n</code></pre>\n<p>Let's get started! This isn't a very complicated problem, so our\nprogram isn't very complicated either.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/base64\"</span>\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-keyword\">const</span> (\n    hexString    <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d\"</span>\n    base64Answer <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    rawBytes, _ := hex.DecodeString(hexString)\n    base64Output := base64.StdEncoding.EncodeToString(rawBytes)\n\n    fmt.Printf(<span class=\"hljs-string\">\"hex encoding: %s\\nbase64 encoding: %s\\n\"</span>, hexString, base64Output)\n\n    <span class=\"hljs-keyword\">if</span> base64Output == base64Answer {\n        fmt.Println(<span class=\"hljs-string\">\"it works! hooray!\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.Println(<span class=\"hljs-string\">\"sad :(\"</span>)\n    }\n}\n</code></pre>\n<p>Basically, all we've done is use some functions from the <code>encoding</code> module.\nI learned a bit about Go syntax, modules, and build stuff doing this.</p>\n"},"ex02":{"title":"Exercise 2","body":"<h1>Exercise 2</h1>\n<p>The <a href=\"http://cryptopals.com/sets/1/challenges/2/\">2nd Matasano challenge</a>!\nNow we're doing fixed XOR. Basically, we have two input strings:</p>\n<pre><code><span class=\"hljs-symbol\">s1:</span> <span class=\"hljs-number\">1</span>c0111001f010100061a024b53535009181c\n<span class=\"hljs-symbol\">s2:</span> <span class=\"hljs-number\">686974207468652062756</span>c6c277320657965\n</code></pre>\n<p>We want to do a pairwise XOR on them (<code>for n in len(s1), do s1[n] XOR s2[n]</code>)\nand check that the output looks like this (when hex encoded):</p>\n<pre><code>output: <span class=\"hljs-number\">746865206</span>b696420646f6e2774<span class=\"hljs-number\">20706c6179</span>\n</code></pre>\n<p>Great, let's go!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n)\n</code></pre>\n<p>First, a little function that performs the XOR operation for us.\nIt just takes in two byte arrays, and iterates through doing the\nXOR operation:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fixedXOR</span><span class=\"hljs-params\">(a1, a2 []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span></span> {\n    bytes = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(a1))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> a1 {\n        bytes[i] = v ^ a2[i]\n    }\n    <span class=\"hljs-keyword\">return</span>\n}\n</code></pre>\n<p>Here's the correct answer, which we'll check after we've done the\ncomputation.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">const</span> correctAnswer <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"746865206b696420646f6e277420706c6179\"</span>\n</code></pre>\n<p>Here's our main function, where we'll do all the work. Go is a bit\nlike C, in that, if you have <code>package main</code> up top, a function called\n<code>main</code> will automatically be called when you run the binary built from\nthis file.</p>\n<p>Go seems to be a bit picky about positional returns - here the\n<code>hex.DecodeString</code> method returns two values, a byte slice and\na boolean that signals if there were any errors.</p>\n<p>We're not really expecting any, so we'll use the <code>_</code> to signal\nthat we don't care about putting a name to that value.</p>\n<p>We also get to use the <code>:=</code> operator, which lets us skip declaring\na type for variables we bind. Anything with an inferrable type (a\nreturn from a function, a literal) will cause the type of our variable\nto be automatically inferred. Handy!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    s1, _ := hex.DecodeString(<span class=\"hljs-string\">\"1c0111001f010100061a024b53535009181c\"</span>)\n    s2, _ := hex.DecodeString(<span class=\"hljs-string\">\"686974207468652062756c6c277320657965\"</span>)\n\n    output := fixedXOR(s1, s2)\n    fmt.Println(hex.EncodeToString(output))\n\n    <span class=\"hljs-keyword\">if</span> hex.EncodeToString(output) == correctAnswer {\n        fmt.Println(<span class=\"hljs-string\">\"It works!\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.Println(<span class=\"hljs-string\">\"It doesn't work so much :(\"</span>)\n    }\n}\n</code></pre>\n<p>That's it! Not too much to this problem, really.</p>\n"},"ex03":{"title":"Exercise 3","body":"<h1>Exercise 3</h1>\n<p><a href=\"http://cryptopals.com/sets/1/challenges/3/\">Matasano exercise 3</a>. This asks\nus to break a single byte XOR. Basically, this means that we have a\nciphertext which has been XORed against a single byte. This means we\ncould exhaustively try every byte until we get it, but we're going to at least\ntry to do something a little more elegant.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n</code></pre>\n<p>First off, something we're almost certainly going to need is a function\nthat takes a byte slice and a byte, and XORs the contents of that byte slice\nwith that byte.</p>\n<p>We'll call it <code>arrayXOR</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">arrayXOR</span><span class=\"hljs-params\">(in []<span class=\"hljs-keyword\">byte</span>, n <span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    out := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(in))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> in {\n        out[i] = v ^ n\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Then if we want to XOR a particular byte, say, 42, with a byte array we can\njust do <code>xorResult := arrayXOR(in, byte(42))</code>. Nice!</p>\n<p>We'll also need two little helper functions. They each take an XORed byte\narray and check that the result has some attribute. The first checks that\nthe result contains only printable ASCII characters, and the second checks\nthat the result contains at least one space character (an assumption we make\nabout the content of the plaintext):</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">asciiCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> bytes {\n        <span class=\"hljs-keyword\">if</span> c &gt; <span class=\"hljs-number\">127</span> || c &lt; <span class=\"hljs-number\">32</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">spaceCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-keyword\">string</span>(bytes) {\n        <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-string\">' '</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>We're going to also make one more assumption about the plaintext: we assume\nthat the most common byte in a decoded plaintext will correspond to one of\nthe letters <code>EAOT</code> or a space, since these are the four most common English\nletters. Here's two functions that check for this scenario. The first takes\na string and returns a <code>map[rune]int</code> giving the character counts in the string:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">charCount</span><span class=\"hljs-params\">(str <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">map</span>[<span class=\"hljs-title\">rune</span>]<span class=\"hljs-title\">int</span></span> {\n    counts := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>)\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> str {\n        counts[c]++\n    }\n    <span class=\"hljs-keyword\">return</span> counts\n}\n</code></pre>\n<p>The second function checks that the most common byte in a putative plaintext\nis one of the characters <code>EAOT</code>. To do this we get the character count of a\nlowercased plaintext, find the most common character, and then check to see\nif that is one of our key characters:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">aeotCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    counts := charCount(strings.ToLower(<span class=\"hljs-keyword\">string</span>(bytes)))\n    <span class=\"hljs-keyword\">var</span> biggest <span class=\"hljs-keyword\">rune</span>\n    count := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> counts {\n        <span class=\"hljs-keyword\">if</span> v &gt; count {\n            biggest = k\n            count = v\n        }\n    }\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">\"aeto \"</span> {\n        <span class=\"hljs-keyword\">if</span> biggest == c {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>Great! Together this lets us define a criterion for a valid plaintext:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">validPlaintext</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> asciiCheck(plain) &amp;&amp; spaceCheck(plain) &amp;&amp; aeotCheck(plain)\n}\n</code></pre>\n<h2>Doing the work</h2>\n<p>Now that we've written all of the functions we'll need, we can try to\nsolve the problem!</p>\n<p>Basically, we're dealing with a keyspace of all the values a single byte\ncan take on (0 - 255). This isn't so many, so while we don't want to just\nmanually check each one, it won't be too much work to check the result of\n'decrypting' with each value for certain attributes.</p>\n<p>So, we're basically going to iterate through all the possible keys, attempt\nto decrypt, and then check <code>validPlaintext</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">const</span> cipherText = <span class=\"hljs-string\">\"1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736\"</span>\n    cipherBytes, _ := hex.DecodeString(cipherText)\n\n    keysAndResults := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>)\n\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">255</span>; i++ {\n        plain := arrayXOR(cipherBytes, i)\n        <span class=\"hljs-keyword\">if</span> validPlaintext(plain) {\n            keysAndResults[i] = <span class=\"hljs-keyword\">string</span>(plain)\n        }\n    }\n\n    <span class=\"hljs-keyword\">for</span> k, plain := <span class=\"hljs-keyword\">range</span> keysAndResults {\n        fmt.Printf(<span class=\"hljs-string\">\"key: %d\\tplaintext: %s\\n\"</span>, k, plain)\n    }\n}\n</code></pre>\n<p>Great! After all that we get one key out the end, and a readable plaintext.</p>\n"},"ex04":{"title":"Exercise 4","body":"<h1>Exercise 4</h1>\n<p>In <a href=\"http://cryptopals.com/sets/1/challenges/4\">exercise 4</a> we're given\n326 60-character hex encoded strings, and we're tasked with figuring out\nwhich one has been encoded with single-byte XOR (as seen in <a href=\"/matasano/ex03.html\">exercise 3</a>).</p>\n<p>Should be fun!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n    <span class=\"hljs-string\">\"sort\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n</code></pre>\n<p>First off, we're going to be re-using a couple of functions we wrote\nfor exercise three. First we'll need our little helper functions to check\nplaintexts, first our <code>onlyASCII</code>, which ensures that we're only dealing with\nprintable ascii characters:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onlyASCII</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> bytes {\n        <span class=\"hljs-keyword\">if</span> !asciiCheck(c) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">asciiCheck</span><span class=\"hljs-params\">(c <span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">if</span> c &gt; <span class=\"hljs-number\">31</span> &amp;&amp; c &lt; <span class=\"hljs-number\">127</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-number\">10</span> || c == <span class=\"hljs-number\">10</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n}\n</code></pre>\n<p>Next is spaceCheck, which just checks that our putative plaintext has a space\nsomewhere in it:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">spaceCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-keyword\">string</span>(bytes) {\n        <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-string\">' '</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>We'll also need our little <code>arrayXOR</code> helper function:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">arrayXOR</span><span class=\"hljs-params\">(in []<span class=\"hljs-keyword\">byte</span>, n <span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    out := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(in))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> in {\n        out[i] = v ^ n\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Next is the most tricky one: scoring based on character count. What we're going\nto want to check is that two of the top four most prevalent characters in a potential\nplaintext are among the characters <code>AEOT</code>. First, a function that takes a string and\nreturns a <code>map[rune]int</code> of characters and their occurences. We'll need to make\nsure that we only pass strings which have been made all lowercase, since we don't\nhave any logic for handling that here:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">charCount</span><span class=\"hljs-params\">(str <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">map</span>[<span class=\"hljs-title\">rune</span>]<span class=\"hljs-title\">int</span></span> {\n    counts := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>)\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> str {\n        counts[c]++\n    }\n    <span class=\"hljs-keyword\">return</span> counts\n}\n</code></pre>\n<p>Now we're going to need to create a named struct type for holding the relevant\ndata, so that we can then implement methods on it to satisfy the sort interface.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> sortableCount <span class=\"hljs-keyword\">struct</span> {\n    runeSlice []<span class=\"hljs-keyword\">rune</span>\n    counts    <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>\n}\n</code></pre>\n<p>So we have <code>sortableCount</code> struct, which has a slice of runes and a <code>map[rune]int</code>. The\nidea is that <code>counts</code> holds the result of calling <code>charCount</code> on a particular string,\nand <code>runeSlice</code> holds the characters that occur in that string, so that we can then\nsort them based on the number of times they occurred.</p>\n<p>Then, following the <a href=\"https://golang.org/pkg/sort/\">sort documentation</a> we need\nto implement the following methods on <code>sortableCount</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(s.runeSlice)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span></span> {\n    s.runeSlice[i], s.runeSlice[j] = s.runeSlice[j], s.runeSlice[i]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> s.counts[s.runeSlice[i]] &lt; s.counts[s.runeSlice[j]]\n}\n</code></pre>\n<p>After implementing these methods we should be able to use the <code>sort.Sort</code> interface\nto sort our array of runes based on the values stored in the map returned by <code>charCount</code>.\nNice!</p>\n<p>Then we can do our check. We're basically going to call <code>charCount</code> to get the counts\nmap, put the characters that we find with charCount into the <code>[]rune</code> slice on our\n<code>sortableCount</code> struct, sort that slice based on the counts, and then finally check that\nat least 2 of the four most common characters are in the set <code>AEOT</code>.</p>\n<p>Here we go:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">aeotCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    sorted := sortableCount{\n        runeSlice: []<span class=\"hljs-keyword\">rune</span>{},\n        counts:    charCount(strings.ToLower(<span class=\"hljs-keyword\">string</span>(bytes))),\n    }\n    <span class=\"hljs-keyword\">for</span> c, _ := <span class=\"hljs-keyword\">range</span> sorted.counts {\n        sorted.runeSlice = <span class=\"hljs-built_in\">append</span>(sorted.runeSlice, c)\n    }\n\n    sort.Sort(sorted)\n\n    length := <span class=\"hljs-built_in\">len</span>(sorted.runeSlice)\n    count := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> i := length - <span class=\"hljs-number\">1</span>; i &gt; length<span class=\"hljs-number\">-4</span>; i-- {\n        <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">\"aeto \"</span> {\n            <span class=\"hljs-keyword\">if</span> sorted.runeSlice[i] == c {\n                count++\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> count == <span class=\"hljs-number\">2</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>Whew! That got a little heavy. Interfaces are kind of cool though, we can <code>sort.Sort()</code>\nanything at all, and all we have to do is implement these three methods that it looks\nfor. I think I'm starting to understand how object oriented programming works in Go,\nand I think I like it.</p>\n<p>Anyway, now that we have our character frequency check sorted out, we'll combine that\nwith the others to check for valid plaintext:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">validPlaintext</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> onlyASCII(plain) &amp;&amp; spaceCheck(plain) &amp;&amp; aeotCheck(plain)\n}\n</code></pre>\n<p>Then using these we can write another helper function that takes\na possible ciphertext and tries to break it:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">breakXOR</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">bool</span>)</span></span> {\n    keysAndResults := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>)\n\n    valid := <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">255</span>; i++ {\n        plain := arrayXOR(plain, i)\n        <span class=\"hljs-keyword\">if</span> validPlaintext(plain) {\n            keysAndResults[i] = <span class=\"hljs-keyword\">string</span>(plain)\n            valid = <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> keysAndResults, valid\n}\n</code></pre>\n<p>Great! Now all we really need to do in <code>main</code> is read in the file,\nand then iterate through and check if <code>breakXOR</code> returns anything. If\nit does, we'll print the output:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    f, _ := os.Open(<span class=\"hljs-string\">\"./exercise_4.txt\"</span>)\n\n    input := bufio.NewScanner(f)\n    <span class=\"hljs-keyword\">for</span> input.Scan() {\n        line, _ := hex.DecodeString(input.Text())\n        keysAndResults, ok := breakXOR(line)\n\n        <span class=\"hljs-keyword\">if</span> ok {\n            <span class=\"hljs-keyword\">for</span> k, plain := <span class=\"hljs-keyword\">range</span> keysAndResults {\n                fmt.Printf(<span class=\"hljs-string\">\"key: %d\\tplaintext: %s\\n\"</span>, k, plain)\n            }\n        }\n    }\n    f.Close()\n}\n</code></pre>\n<p>And it works! Hooray!</p>\n<p>I'm not sure that my approach here is ultimately correct. In particular,\nthe <code>aeotCheck</code> method is not particularly scientific, but instead based on a\nlittle bit of fine-tuning in order to get the right answer.</p>\n<p>But it works, so who cares!</p>\n"}}