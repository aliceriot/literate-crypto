{"undefined":{"title":"Exercise 4","body":"<h1>Exercise 4</h1>\n<p>In <a href=\"http://cryptopals.com/sets/1/challenges/4\">exercise 4</a> we're given\n326 60-character hex encoded strings, and we're tasked with figuring out\nwhich one has been encoded with single-byte XOR (as seen in <a href=\"/matasano/ex03.html\">exercise 3</a>).</p>\n<p>Should be fun!</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"encoding/hex\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n    <span class=\"hljs-string\">\"sort\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n</code></pre>\n<p>First off, we're going to be re-using a couple of functions we wrote\nfor exercise three. First we'll need our little helper functions to check\nplaintexts, first our <code>onlyASCII</code>, which ensures that we're only dealing with\nprintable ascii characters:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">onlyASCII</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> bytes {\n        <span class=\"hljs-keyword\">if</span> !asciiCheck(c) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">asciiCheck</span><span class=\"hljs-params\">(c <span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">if</span> c &gt; <span class=\"hljs-number\">31</span> &amp;&amp; c &lt; <span class=\"hljs-number\">127</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-number\">10</span> || c == <span class=\"hljs-number\">10</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n}\n</code></pre>\n<p>Next is spaceCheck, which just checks that our putative plaintext has a space\nsomewhere in it:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">spaceCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-keyword\">string</span>(bytes) {\n        <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-string\">' '</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>We'll also need our little <code>arrayXOR</code> helper function:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">arrayXOR</span><span class=\"hljs-params\">(in []<span class=\"hljs-keyword\">byte</span>, n <span class=\"hljs-keyword\">byte</span>)</span> []<span class=\"hljs-title\">byte</span></span> {\n    out := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">byte</span>, <span class=\"hljs-built_in\">len</span>(in))\n    <span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> in {\n        out[i] = v ^ n\n    }\n    <span class=\"hljs-keyword\">return</span> out\n}\n</code></pre>\n<p>Next is the most tricky one: scoring based on character count. What we're going\nto want to check is that two of the top four most prevalent characters in a potential\nplaintext are among the characters <code>AEOT</code>. First, a function that takes a string and\nreturns a <code>map[rune]int</code> of characters and their occurences. We'll need to make\nsure that we only pass strings which have been made all lowercase, since we don't\nhave any logic for handling that here:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">charCount</span><span class=\"hljs-params\">(str <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">map</span>[<span class=\"hljs-title\">rune</span>]<span class=\"hljs-title\">int</span></span> {\n    counts := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>)\n    <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> str {\n        counts[c]++\n    }\n    <span class=\"hljs-keyword\">return</span> counts\n}\n</code></pre>\n<p>Now we're going to need to create a named struct type for holding the relevant\ndata, so that we can then implement methods on it to satisfy the sort interface.</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> sortableCount <span class=\"hljs-keyword\">struct</span> {\n    runeSlice []<span class=\"hljs-keyword\">rune</span>\n    counts    <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">rune</span>]<span class=\"hljs-keyword\">int</span>\n}\n</code></pre>\n<p>So we have <code>sortableCount</code> struct, which has a slice of runes and a <code>map[rune]int</code>. The\nidea is that <code>counts</code> holds the result of calling <code>charCount</code> on a particular string,\nand <code>runeSlice</code> holds the characters that occur in that string, so that we can then\nsort them based on the number of times they occurred.</p>\n<p>Then, following the <a href=\"https://golang.org/pkg/sort/\">sort documentation</a> we need\nto implement the following methods on <code>sortableCount</code>:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Len</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(s.runeSlice)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span></span> {\n    s.runeSlice[i], s.runeSlice[j] = s.runeSlice[j], s.runeSlice[i]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s sortableCount)</span> <span class=\"hljs-title\">Less</span><span class=\"hljs-params\">(i, j <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> s.counts[s.runeSlice[i]] &lt; s.counts[s.runeSlice[j]]\n}\n</code></pre>\n<p>After implementing these methods we should be able to use the <code>sort.Sort</code> interface\nto sort our array of runes based on the values stored in the map returned by <code>charCount</code>.\nNice!</p>\n<p>Then we can do our check. We're basically going to call <code>charCount</code> to get the counts\nmap, put the characters that we find with charCount into the <code>[]rune</code> slice on our\n<code>sortableCount</code> struct, sort that slice based on the counts, and then finally check that\nat least 2 of the four most common characters are in the set <code>AEOT</code>.</p>\n<p>Here we go:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">aeotCheck</span><span class=\"hljs-params\">(bytes []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    sorted := sortableCount{\n        runeSlice: []<span class=\"hljs-keyword\">rune</span>{},\n        counts:    charCount(strings.ToLower(<span class=\"hljs-keyword\">string</span>(bytes))),\n    }\n    <span class=\"hljs-keyword\">for</span> c, _ := <span class=\"hljs-keyword\">range</span> sorted.counts {\n        sorted.runeSlice = <span class=\"hljs-built_in\">append</span>(sorted.runeSlice, c)\n    }\n\n    sort.Sort(sorted)\n\n    length := <span class=\"hljs-built_in\">len</span>(sorted.runeSlice)\n    count := <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> i := length - <span class=\"hljs-number\">1</span>; i &gt; length<span class=\"hljs-number\">-4</span>; i-- {\n        <span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> <span class=\"hljs-string\">\"aeto \"</span> {\n            <span class=\"hljs-keyword\">if</span> sorted.runeSlice[i] == c {\n                count++\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> count == <span class=\"hljs-number\">2</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>Whew! That got a little heavy. Interfaces are kind of cool though, we can <code>sort.Sort()</code>\nanything at all, and all we have to do is implement these three methods that it looks\nfor. I think I'm starting to understand how object oriented programming works in Go,\nand I think I like it.</p>\n<p>Anyway, now that we have our character frequency check sorted out, we'll combine that\nwith the others to check for valid plaintext:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">validPlaintext</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n    <span class=\"hljs-keyword\">return</span> onlyASCII(plain) &amp;&amp; spaceCheck(plain) &amp;&amp; aeotCheck(plain)\n}\n</code></pre>\n<p>Then using these we can write another helper function that takes\na possible ciphertext and tries to break it:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">breakXOR</span><span class=\"hljs-params\">(plain []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">bool</span>)</span></span> {\n    keysAndResults := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">byte</span>]<span class=\"hljs-keyword\">string</span>)\n\n    valid := <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-number\">0</span>); i &lt; <span class=\"hljs-number\">255</span>; i++ {\n        plain := arrayXOR(plain, i)\n        <span class=\"hljs-keyword\">if</span> validPlaintext(plain) {\n            keysAndResults[i] = <span class=\"hljs-keyword\">string</span>(plain)\n            valid = <span class=\"hljs-literal\">true</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> keysAndResults, valid\n}\n</code></pre>\n<p>Great! Now all we really need to do in <code>main</code> is read in the file,\nand then iterate through and check if <code>breakXOR</code> returns anything. If\nit does, we'll print the output:</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    f, _ := os.Open(<span class=\"hljs-string\">\"./exercise_4.txt\"</span>)\n\n    input := bufio.NewScanner(f)\n    <span class=\"hljs-keyword\">for</span> input.Scan() {\n        line, _ := hex.DecodeString(input.Text())\n        keysAndResults, ok := breakXOR(line)\n\n        <span class=\"hljs-keyword\">if</span> ok {\n            <span class=\"hljs-keyword\">for</span> k, plain := <span class=\"hljs-keyword\">range</span> keysAndResults {\n                fmt.Printf(<span class=\"hljs-string\">\"key: %d\\tplaintext: %s\\n\"</span>, k, plain)\n            }\n        }\n    }\n    f.Close()\n}\n</code></pre>\n<p>And it works! Hooray!</p>\n<p>I'm not sure that my approach here is ultimately correct. In particular,\nthe <code>aeotCheck</code> method is not particular scientific, but instead based on a\nlittle bit of fine-tuning in order to get the right answer.</p>\n<p>But it works, so who cares!</p>\n"}}